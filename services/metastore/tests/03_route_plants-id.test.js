'use strict'

const chai = require('chai')
chai.should()
const expect = chai.expect

const chaiHttp = require('chai-http')
chai.use(chaiHttp)

const chaiLike = require('chai-like')
chai.use(chaiLike)

const server = require('../server')

const MongoClient = require('mongodb').MongoClient
const ObjectID = require('mongodb').ObjectID
const MongoMemServ = require('./MongoMemoryServerHandler')

const apiBasePath = '/api'

describe('/plants/:id', () => {
  const correctlyFormedIdThatDoesntExist = '5f1637a2e99ac7d700000000'
  const malformedId = 'not24HexChars'

  let mongoClient
  let mongoDbInstance
  let mockObjects

  beforeEach(async () => {
    // start and initialize in-memory db server:
    await MongoMemServ.start()
    mockObjects = await MongoMemServ.init({
      plants: [
        { name: 'Gerhard' },
        { name: 'Franzi' },
        {
          name: 'Basilikum',
          deviceCode: 'bar'
        },
        {
          name: 'multi levels deep',
          measurands: {
            humidity: {
              healthyMax: 82,
              healthyMin: 30
            }
          }
        }
      ]
    })

    // start instance of db client:
    mongoClient = new MongoClient(
      MongoMemServ.getUri(),
      {
        useNewUrlParser: true,
        useUnifiedTopology: true
      }
    )

    await mongoClient.connect()

    mongoDbInstance = await mongoClient.db(MongoMemServ.getDbName())
  })

  afterEach(async () => {
    // stop client:
    await mongoClient.close()

    // stop in-memory server:
    await MongoMemServ.stop()
  })

  describe('GET', () => {
    it('should return the json object of the plant with the given :id', async () => {
      for (const entry of mockObjects.plants) {
        const res = await chai.request(server)
          .get(apiBasePath + '/plants/' + entry._id)

        res.should.have.status(200)
        res.should.have.header('content-type', 'application/json; charset=utf-8')
        res.body.should.be.an('object')

        expect(res.body.id).to.exist
        res.body.id.should.equal(res.body._id)

        entry.id = entry._id // field id should contain DB id
        // res.body.should.deep.equal(entry)
        JSON.stringify(res.body).should.be.eql(JSON.stringify(entry))
      }
    })

    it('should return 404 with an error message, if the plant with the given :id doesn\'t exist', async () => {
      // for proper MongoDB id's:
      const res1 = await chai.request(server)
        .get(apiBasePath + '/plants/' + correctlyFormedIdThatDoesntExist)

      res1.should.have.status(404)
      res1.should.have.header('content-type', 'application/json; charset=utf-8')
      res1.body.error.should.be.true
      res1.body.message.should.equal('Plant with given :id does not exist')

      // for all other strings:
      const res2 = await chai.request(server)
        .get(apiBasePath + '/plants/' + malformedId)

      res2.should.have.status(404)
      res2.should.have.header('content-type', 'application/json; charset=utf-8')
    })
  })

  describe('PUT', () => {
    it('should completely replace the object with the given :id in the database with the object passed in req.body and return 200', async () => {
      const originalPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[2]._id) })

      originalPlant.name.should.equal('Basilikum')
      originalPlant.deviceCode.should.equal('bar')

      const res = await chai.request(server)
        .put(apiBasePath + '/plants/' + mockObjects.plants[2]._id)
        .type('json')
        .send({
          name: 'Foo'
        })

      res.should.have.status(200)

      // if I just want to check if the single entry was updated
      // const updatedPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[2]._id) })
      // updatedPlant.name.should.equal('Foo')

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()
      mockObjects.plants[2].name = 'Foo'
      delete mockObjects.plants[2].deviceCode

      allPlants.should.deep.equal(mockObjects.plants)
    })

    it('should return 403 with an error message, if an object with the given :id does not exist in the database. It should not create a new entry in the database as :id\'s are auto-generated by the database and can\'t be defined by the user', async () => {
      const res = await chai.request(server)
        .put(apiBasePath + '/plants/' + correctlyFormedIdThatDoesntExist)
        .type('json')
        .send({
          name: 'Foo'
        })

      res.should.have.status(403)
      res.should.have.header('content-type', 'application/json; charset=utf-8')
      res.body.error.should.be.true
      res.body.message.should.equal('Plant with given :id does not exist. Creation of new entities via put is not permitted!')

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()

      allPlants.should.deep.equal(mockObjects.plants)
    })
  })

  describe('PATCH', () => {
    it('should update the entries of the object with the given :id in the database with the respective entries from the object passed in req.body and return 200', async () => {
      const originalPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[2]._id) })

      originalPlant.name.should.equal('Basilikum')
      originalPlant.deviceCode.should.equal('bar')

      const res = await chai.request(server)
        .patch(apiBasePath + '/plants/' + mockObjects.plants[2]._id)
        .type('json')
        .send({
          name: 'Foo',
          deviceCode: 'baz'
        })

      res.should.have.status(200)

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()
      mockObjects.plants[2].name = 'Foo'
      mockObjects.plants[2].deviceCode = 'baz'

      allPlants.should.deep.equal(mockObjects.plants)
    })

    it('should NOT remove entries from the object in the database that are missing in the object passed in req.body', async () => {
      const originalPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[2]._id) })

      originalPlant.name.should.equal('Basilikum')
      originalPlant.deviceCode.should.equal('bar')

      const res = await chai.request(server)
        .patch(apiBasePath + '/plants/' + mockObjects.plants[2]._id)
        .type('json')
        .send({
          deviceCode: 'baz'
        })

      res.should.have.status(200)

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()
      mockObjects.plants[2].name = 'Basilikum' // not changed
      mockObjects.plants[2].deviceCode = 'baz' // updated

      allPlants.should.deep.equal(mockObjects.plants)
    })

    it('should add additional entries from the object passed in req.body to the object in the database', async () => {
      const originalPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[0]._id) })

      originalPlant.name.should.equal('Gerhard')
      expect(originalPlant.deviceCode).to.be.undefined

      const res = await chai.request(server)
        .patch(apiBasePath + '/plants/' + mockObjects.plants[0]._id)
        .type('json')
        .send({
          name: 'bar',
          deviceCode: 'baz'
        })

      res.should.have.status(200)

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()
      mockObjects.plants[0].name = 'bar' // changed
      mockObjects.plants[0].deviceCode = 'baz' // added

      allPlants.should.deep.equal(mockObjects.plants)
    })

    it('should recursively patch the object multiple levels deep', async () => {
      const originalPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[3]._id) })

      const expectedObjectBefore = {
        name: 'multi levels deep',
        measurands: {
          humidity: {
            healthyMax: 82,
            healthyMin: 30
          }
        }
      }

      // remove auto-generated keys:
      delete originalPlant.__v
      delete originalPlant._id

      originalPlant.should.deep.equal(expectedObjectBefore)

      // run patch operation:
      const res = await chai.request(server)
        .patch(apiBasePath + '/plants/' + mockObjects.plants[3]._id)
        .type('json')
        .send({
          name: 'multi levels modified', // changed
          measurands: {
            humidity: {
              healthyMin: 42 // one of the object keys changed
            }
          },
          deviceCode: 'test' // added
        })

      res.should.have.status(200)

      const modifiedPlant = await mongoDbInstance.collection('plants').findOne({ _id: new ObjectID(mockObjects.plants[3]._id) })

      // remove auto-generated keys:
      delete modifiedPlant.__v
      delete modifiedPlant._id

      const expectedObjectAfter = {
        name: 'multi levels modified',
        measurands: {
          humidity: {
            healthyMax: 82,
            healthyMin: 42
          }
        },
        deviceCode: 'test'
      }

      modifiedPlant.should.deep.equal(expectedObjectAfter)
    })
  })

  describe('DELETE', () => {
    it('should remove the plant with the given :id from the database and return 204', async () => {
      const res = await chai.request(server)
        .delete(apiBasePath + '/plants/' + mockObjects.plants[0]._id)

      res.should.have.status(204)

      const allPlants = await mongoDbInstance.collection('plants').find({}).toArray()

      mockObjects.plants.shift() // remove first element form array (that's the one with index 0 ;-))

      allPlants.should.deep.equal(mockObjects.plants)
    })

    it('should return status 404 with an error message, if the plant with the given :id doesn\'t exist and thus can\'t be deleted', async () => {
      const res = await chai.request(server)
        .delete(apiBasePath + '/plants/' + correctlyFormedIdThatDoesntExist)

      res.should.have.status(404)
      res.should.have.header('content-type', 'application/json; charset=utf-8')
      res.body.error.should.be.true
      res.body.message.should.equal('Plant with given :id does not exist')
    })
  })
})
